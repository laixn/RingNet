<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8">
 <title>Multi-omics Visulization</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.6.0/dist/svg2pdf.umd.min.js"></script>

  <script> 
  // jspdf creation function
  window.jsPDF = window.jspdf && window.jspdf.jsPDF;

  // svg2pdf.umd.min.js  include a object which has svg2pdf / default function
  (function () {
    var lib = window.svg2pdf;   // object
    var fn  = null;

    if (typeof lib === 'function') {
      fn = lib;
    } else if (lib && typeof lib.svg2pdf === 'function') {
      fn = lib.svg2pdf;
    } else if (lib && typeof lib.default === 'function') {
      fn = lib.default;
    }

    if (fn) {
      window.svg2pdfFn = fn;    
      window.svg2pdf    = fn;   
    }

    console.log('svg2pdf raw =', typeof lib);
    console.log('svg2pdfFn  =', typeof window.svg2pdfFn);
    console.log('jsPDF      =', typeof window.jsPDF);
  })();
  </script>

  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }
    #controls {
      padding: 10px;
      background: #f7f7f7;
      border-bottom: 1px solid #ddd;
      position: fixed; /* stick on the top  */
      top: 0; left: 0; right: 0;
      min-height: 100px;    
      z-index: 100;
    }

    #controls label, #controls div {
      margin-right: 20px;
      display: inline-block;
      vertical-align: middle;
    }
    #controls input[type="color"] {
      width: 24px;
      height: 24px;
      padding: 0;
      border: none;
      margin-left: 4px;
      vertical-align: middle;
    }
    /********************************************/
    #networkContainer {
     position: absolute;
     top: 100px; left: 0; right: 0; bottom: 0;
     overflow: auto;      /* can always roll */
     background: white;

    
    }

    #networkViz {
      display: block;
      width: 700%;    /*  2 times wider than initial width */
      height: 700%;   /*  2 times wider than initial width */
      background: white;
    }
    #zoomControls {
      position: fixed;
      top: 120px;
      right: 20px;
      z-index: 200;
    }

    #zoomControls button {
      display: block;
      margin-bottom: 5px;
      font-size: 18px;
      width: 40px;
      height: 40px;
    }
	#networkViz {
      cursor: grab;      /* hand symbol*/
     }

    #networkViz:active {
      cursor: grabbing;  /* when the mouse goes down, the hand symbol will goes down */
    }
  </style>
</head>
<body>
  <div id="controls">
    <label>
      Network：
      <select id="commSelect"></select>
    </label>
    <label>
      Degree Range：
      <input type="number" id="degMin" value="0" min="0" max="500" style="width:60px;">
      –
      <input type="number" id="degMax" value="500" min="0" max="500" style="width:60px;">
       <button id="fitBtn">Fit</button>
       <button id="saveSVGBtn">Save SVG</button>
       <button id="savePDFBtn">Save PDF</button>
       <button id="saveJSONBtn">Save JSON</button>

     </label>
     <br> 
     <div id="colorPickers" style="margin-top:8px;">
	  <span>Data1：</span>
	  <input type="color" id="expNeg" value="#0000FF" title="Exp Negative" />
	  <input type="color" id="expZero" value="#F7F7F7" title="Exp Zero" />
	  <input type="color" id="expPos" value="#FF0000" title="Exp Positive" />
      <span style="display:inline-block; width:30px;"></span>  
      <span>Data2：</span>
      <input type="color" id="mtyNeg" value="#0000FF" title="Mty Negative" />
      <input type="color" id="mtyZero" value="#F7F7F7" title="Mty Zero" />
      <input type="color" id="mtyPos" value="#FF0000" title="Mty Positive" />
      <span style="display:inline-block; width:30px;"></span> 
      <span>Data3：</span>
      <input type="color" id="cnvNeg" value="#0000FF" title="CNV Negative" />
      <input type="color" id="cnvZero" value="#F7F7F7" title="CNV Zero" />
      <input type="color" id="cnvPos" value="#FF0000" title="CNV Positive" />
      <span style="display:inline-block; width:30px;"></span>
      <span>Data4：</span>
      <input type="color" id="snvNeg"  value="#0000FF" title="SNV Negative" />
      <input type="color" id="snvZero" value="#F7F7F7" title="SNV Zero" />    
      <input type="color" id="snvPos"  value="#FF0000" title="SNV Positive" />
      <br>
    </div>  
    <br>
    <div style="display:inline-block; margin-top:0; vertical-align:middle;">
     <label>
       Data:
       <select id="omicsType">
        <option value="exp">Data1</option>
        <option value="mty">Data2</option>
        <option value="cnv">Data3</option>
        <option value="snv">Data4</option>
       </select>
      </label>
     <label>
       Data Norm:
      <select id="dataType">
        <option value="raw">Raw</option>
        <option value="norm">Min-Max norm</option>
        <option value="zscore">Z-score</option>
       </select>
      </label>
      <label>

     <label>
       Value Range:
        <input type="number" id="rangeMin" value="-1" step="0.1" style="width:60px;"> -
        <input type="number" id="rangeMax" value="1" step="0.1" style="width:60px;">
     </label>
       <button id="filterBtn">Filter</button>
     </div>
     <br>
     <div class="legend-row" style="margin-top:8px;">
       <span>Group：</span>
       <span id="stageLegend" class="legend-inline"></span>
     </div>
    <br>
    <div>
      <span>Edges：</span>
      Negative: <input type="color" id="edgeNeg" value="#00FF00" title="Negative weight" />
      Zero: <input type="color" id="edgeZero" value="#FFFFFF" title="Zero weight" />
      Postive: <input type="color" id="edgePos" value="#FF00FF" title="Postive Weight" />
     </div>
  <br>
  <div style="margin-top:8px;">
    <span>Edge Data Norm:</span>
    <select id="edgeMetric">
     <option value="w_raw">Raw</option>
     <option value="w_norm">Min-Max Norm</option>
     <option value="w_z">Z-score</option>
    </select>
    <label style="margin-left:12px;">
      Range:
     <input type="number" id="eRangeMin" value="-1" step="0.1" style="width:80px;">
      –
     <input type="number" id="eRangeMax" value="1"  step="0.1" style="width:80px;">
    </label>
    <button id="edgeFilterBtn">Filter edges</button>
	<label style="margin-left:12px;">
      <input type="checkbox" id="useInteract">
      color by interact_id
    </label>
  </div>


  </div>
    
  <!-- zoom control item displaying on the right -->
	<div id="zoomControls">
	  <button id="zoomIn">➕</button>
	  <button id="zoomOut">➖</button>
	</div>
   
  
  
   <div id="networkContainer">
     <svg id="networkViz">
      <defs>
      <!-- arrows marker -->
         <marker id="arrow" viewBox="0 -5 10 10"
                refX="6" refY="0"
                markerUnits="strokeWidth"
                markerWidth="6"
                markerHeight="6"
                orient="auto">
          <path d="M0,-5L10,0L0,5" fill="context-stroke"/>
        </marker>
     </defs>
        
    </svg>
        
    </div>
  
  <script>
  (function(){
    
    let currentData = null;
    let lastLayout = []; 
	let layoutByCommunity = new Map();
    let currentCommId = null;
    let nodeSel = null;          // d3 selection of g.node
    let edgeSelStraight = null;  // d3 selection of line.edge
    let edgeSelCurved = null;    // d3 selection of path.edge
    const viewWidth  = window.innerWidth;
    const viewHeight = window.innerHeight - 100;  

    // set SVG in standard size
    const svg = d3.select('#networkViz')
      .attr('width',  viewWidth)
      .attr('height', viewHeight);
    const container = svg.append('g');
	const scrollContainer = document.getElementById('networkContainer');
	const zoom = d3.zoom()
     .scaleExtent([0.2, 8]) // the range of zoom
     .on('zoom', (event) => {
       // move zoom in are on container <g>
       container.attr('transform', event.transform);
     });
   

     svg.call(zoom)
      .on('wheel.zoom', null)       // 禁止滚轮缩放 forbide zoom in with roll 
      .on('dblclick.zoom', null)    // 禁止双击缩放 forbide zoom in by double click

	 window.zoomBehavior = zoom;
	
     let colorConfig = {};
	 const INTERACT_COLORS = [
       '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
       '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
       '#393b79','#637939','#8c6d31','#843c39','#7b4173',
       '#3182bd','#e6550d','#31a354','#756bb1','#636363',
       '#6baed6','#fd8d3c','#74c476','#9e9ac8','#bdbdbd',
       '#9ecae1','#fdae6b','#a1d99b','#bcbddc','#d9d9d9'
     ];
     
     // choose interact id model?
     let useInteractMode = false;

    // each omic value form ：raw / norm / zscore
     const METRICS = ['raw', 'norm', 'zscore'];
     let omicsMetric = {
       exp: 'raw',
       mty: 'raw',
       snv: 'raw',
       cnv: 'raw'
     };
	 function getColorScales() {
	   // gene expression
	   colorConfig.exp = d3.scaleLinear()
	     .domain([-1, 0, 1])
	     .range([
	       d3.select('#expNeg').property('value'),
	       d3.select('#expZero').property('value'),
	       d3.select('#expPos').property('value')
	     ]);
	
	   // methylation
	   colorConfig.mty = d3.scaleLinear()
	     .domain([-1, 0, 1])
	     .range([
	       d3.select('#mtyNeg').property('value'),
	       d3.select('#mtyZero').property('value'),
	       d3.select('#mtyPos').property('value')
	     ]);
	
	   // Single Nucleotide Variant
           colorConfig.snv = d3.scaleLinear()
              .domain([-1, 0, 1])
              .range([
                   d3.select('#snvNeg').property('value'),
                   d3.select('#snvZero').property('value'),
                   d3.select('#snvPos').property('value')
           ]);	
	   // copy number variation 
	   colorConfig.cnv = d3.scaleLinear()
	     .domain([-1, 0, 1])
	     .range([
	       d3.select('#cnvNeg').property('value'),
	       d3.select('#cnvZero').property('value'),
	       d3.select('#cnvPos').property('value')
	     ]);
	
	   // edge
	   colorConfig.edge = {
	     neg:  d3.select('#edgeNeg').property('value'),
	     zero: d3.select('#edgeZero').property('value'),
	     pos:  d3.select('#edgePos').property('value')
	   };
	 }
	
	
	 const DEFAULT_STAGE_COLORS = [
	   '#1f77b4', // 0
	   '#d62728', // 1
	   '#2ca02c', // 2
	   '#ffbf00', // 3
	   '#9467bd', // 4
	   '#ff7f0e'  // 5
	 ];
	
	const STAGE_IDS = [0,1,2,3,4,5];
	const stageColorMap = new Map(STAGE_IDS.map(i => [i, DEFAULT_STAGE_COLORS[i]]));
	
	
	function setStageColor(i, hex) {
	  if (!Number.isInteger(i) || i < 0) return;
	  if (/^#[0-9A-Fa-f]{6}$/.test(hex)) stageColorMap.set(i % STAGE_IDS.length, hex);
	}
	function getStageColorByIndex(v) {
	  const n = Number(v);
	  if (!Number.isFinite(n)) return 'transparent';
	  const i = Math.floor(n);
	  if (i < 0) return 'transparent'; // if data=-1,it can be transparent
	  const k = i % STAGE_IDS.length;
	  return stageColorMap.get(k) || DEFAULT_STAGE_COLORS[k];
	}
	
	
	 
	
	function renderStageLegend() {
	  const container = d3.select('#stageLegend');
	  if (container.empty()) return;
	
	  container.selectAll('*').remove();
	
	  const wrap = container.append('div')
	    .style('display','inline-flex')
	    .style('gap','14px')
	    .style('align-items','center')
	    .style('flex-wrap','wrap');
	
	  // calculate the live group existing in community
	  const present = new Set();
	  if (currentData?.nodes?.length) {
	    currentData.nodes.forEach(n => {
	      const arr = Array.isArray(n.stage_idx) ? n.stage_idx : [];
	      arr.forEach(v => {
	        const x = Math.floor(+v);
	        if (Number.isFinite(x) && x >= 0) present.add(x % STAGE_IDS.length);
	      });
	    });
	  }
	
	  STAGE_IDS.forEach(i => {
	    const hasData = present.has(i);
	    const color = stageColorMap.get(i) || DEFAULT_STAGE_COLORS[i];
	
	    const row = wrap.append('label')
	      .style('display','inline-flex')
	      .style('align-items','center')
	      .style('gap','8px');
	
	    row.append('span')
	      .text(`group ${i}`)
	      .style('opacity', hasData ? 1 : 0.45);
	
	    row.append('input')
	      .attr('type','color')
	      .attr('id', `stageColor-${i}`)
	      .attr('value', color)
	      .property('value', color)
	      .property('disabled', !hasData)               // no data will be forbidden
	      .style('width','28px')                        
	      .style('height','28px')
	      .style('padding','0')
	      .style('border','1px solid #ccc')
	      .style('cursor', hasData ? 'pointer' : 'not-allowed')
	      // visulization
	      .style('filter', hasData ? null : 'grayscale(100%) brightness(0.85)')
	      .style('opacity', hasData ? 1 : 0.7)
	      .on('input', function () {
	        if (!hasData) return;
	        setStageColor(i, this.value);
	        updateStyles();
	      })
	      .on('change', function () {
	        if (!hasData) return;
	        setStageColor(i, this.value);
	        updateStyles();
	      });
	  });
	}

  //load json file

	const sid = new URLSearchParams(location.search).get('sid') || '';
	const jsonPath = sid ? `uploads/${sid}/community_map_top100.json`: 'uploads/community_map_top100.json';
	fetch(jsonPath)
	 .then(r => r.json())
	 .then(json => {
	  const dataArr = Array.isArray(json) ? json : Object.values(json);
	  window.allCommunities = dataArr;
	  const sel = d3.select('#commSelect');
	  /* drop-down menu */
	  dataArr.forEach(item => {
	    sel.append('option')
	       .attr('value', item.comm)
	       .text(`Network ${item.comm}`);
	  });
	
	
	  sel.property('value', dataArr[0].comm);
	  getColorScales();
	  sel.on('change', renderCommunity);
	  renderCommunity();                // initial render
	
	  d3.selectAll('#degMin, #degMax').on('change', renderCommunity); 
	
	  // Color picker change → redraw immediately 
	 d3.selectAll('#colorPickers input[type="color"]').on('input', () => {
	  getColorScales();
      updateStyles();
	 });
	  d3.selectAll('#edgeNeg, #edgeZero, #edgePos').on('input', () => {
	      getColorScales();
          updateStyles();
	 });
	
	
	   // Edge metric switch (Raw/Norm/Z) → reset range + redraw
	  d3.select('#edgeMetric').on('change', () => {
	   if (!currentData) return;
       setEdgeRangeInputs(currentData.edges);
       updateStyles();
	  });
	
	  // Edge range input change → redraw
	  d3.selectAll('#eRangeMin, #eRangeMax').on('change', () => {
	    updateStyles();
	  });
	
	  // 'Filter edges' button → redraw
	  d3.select('#edgeFilterBtn').on('click', () => {
	     updateStyles();
	  });
	  const fitBtn = document.getElementById('fitBtn');
	  if (fitBtn) fitBtn.onclick = () => fitToView();
	
	  const saveSVGBtn = document.getElementById('saveSVGBtn');
	  if (saveSVGBtn) saveSVGBtn.onclick = () => saveSVG();
	
	  const savePDFBtn = document.getElementById('savePDFBtn');
	  if (savePDFBtn) savePDFBtn.onclick = () => savePDF();
	  const useInteractCheckbox = d3.select('#useInteract');
      if (!useInteractCheckbox.empty()) {
        useInteractCheckbox.on('change', function () {
          useInteractMode = this.checked;
          updateStyles();
        });
      }
	    })
	.catch(err => console.error('JSON loading failed:', err));
	
	
	
	 function setEdgeRangeInputs(edges) {
	  const metric = d3.select('#edgeMetric').property('value');
	  const toNum = v => {
	    if (Array.isArray(v)) v = v[0];
	    const n = +v;
	    return Number.isFinite(n) ? n : NaN;
	  };
	  const vals = edges
	    .map(e => toNum((e && e[metric]) ?? e?.weight))
	    .filter(Number.isFinite);
	
	  if (!vals.length) return;
	
	  let emin = d3.min(vals), emax = d3.max(vals);
	  if (emin === emax) {
	    const pad = Math.max(1e-6, Math.abs(emin) * 0.01 || 0.01);
	    emin -= pad; emax += pad;
	  }
	  d3.select('#eRangeMin').property('value', emin.toFixed(3));
	  d3.select('#eRangeMax').property('value', emax.toFixed(3));
	}			    


    // render the specific communtiy
  
    // when switching network or change degree range, it can be used to create new layout
     function renderCommunity() {

      console.log('renderCommunity called');
      const id = d3.select('#commSelect').property('value');
      
      if (currentCommId && lastLayout.length) {
        layoutByCommunity.set(currentCommId, lastLayout.slice());
      }
      currentCommId = id;
      
      const dmin = +d3.select('#degMin').property('value');
      const dmax = +d3.select('#degMax').property('value');
      
      const raw = window.allCommunities.find(d => String(d.comm) === id);
      if (!raw) {
        console.warn('community does not exist:', id);
        return;
      }
    
   
      function getId(v) {
        if (Array.isArray(v)) return getId(v[0]);
        if (typeof v === 'object' && v !== null) return getId(v.id);
        return String(v);
      }
      
      const nodesById = new Map(
        raw.nodes.map(n => [ getId(n.id), n ])
      );
      
      // 1. core node in range [dmin, dmax]
      const inRangeIds = new Set(
        raw.nodes
          .filter(n => n.degree >= dmin && n.degree <= dmax)
          .map(n => getId(n.id))
      );
      
      // 2. High-order neighbors: nodes with degree > dmax that are connected by at least one edge to a core node.
      const highNeighborIds = new Set();

      raw.edges.forEach(e => {
      const sId = getId(e.source);
      const tId = getId(e.target);
      const sNode = nodesById.get(sId);
      const tNode = nodesById.get(tId);
      if (!sNode || !tNode) return;
     
      const sIn = inRangeIds.has(sId);
      const tIn = inRangeIds.has(tId);
       
      if (sIn && tNode.degree > dmax) highNeighborIds.add(tId);
      if (tIn && sNode.degree > dmax) highNeighborIds.add(sId);
      });

      // 3. The set of nodes to be retained: the union of core nodes and high-order neighbors
      const usedIdSet = new Set([...inRangeIds, ...highNeighborIds]);
      
      const nodesUsed = raw.nodes.filter(n => {
      const nid = getId(n.id);
      return usedIdSet.has(nid);
      });
    
    // 4. Edges to be retained:
    //    - both endpoints are in usedIdSet
    //    - and at least one endpoint is in inRangeIds (must be adjacent to a core node)
      const edgesUsed = raw.edges.filter(e => {
        const sId = getId(e.source);
        const tId = getId(e.target);
      
        if (!usedIdSet.has(sId) || !usedIdSet.has(tId)) return false;
        return inRangeIds.has(sId) || inRangeIds.has(tId);
      });
      
      const data = {
        nodes: nodesUsed,
        edges: edgesUsed
      };
      
      console.log(
      'degRange =', dmin, dmax,
      'coreNodes =', inRangeIds.size,
      'highNeighbors =', highNeighborIds.size,
      'nodesUsed =', nodesUsed.length,
      'edgesUsed =', edgesUsed.length
      );
    
     const savedLayout = layoutByCommunity.get(id);
     if (savedLayout && savedLayout.length) {
       const layoutMap = new Map(savedLayout.map(p => [String(p.id), p]));
       data.nodes.forEach(n => {
         const nid = String(Array.isArray(n.id) ? n.id[0] : n.id);
         const p = layoutMap.get(nid);
         if (p) { n.x = p.x; n.y = p.y; }
       });
     } else {
       computeLayoutOnce(data);  
       const layout = data.nodes.map(n => ({
         id: String(Array.isArray(n.id) ? n.id[0] : n.id),
         x: n.x,
         y: n.y
       }));
       layoutByCommunity.set(id, layout);
     }
    
     currentData = data;
     lastLayout = (layoutByCommunity.get(id) || []).slice();
    
     updateValueRangeInputs(data.nodes);
     renderStageLegend();
     setEdgeRangeInputs(data.edges);
    
     buildNetwork(data);
    

    // Invoked only upon network changes or degree range updates;
    // performs a single force-based layout computation.
    function computeLayoutOnce(data) {
      const svg = d3.select('#networkViz');
      const width  = +svg.attr('width')  || 1000;
      const height = +svg.attr('height') || 700;
    
      const nodes = data.nodes;
      const edges = data.edges;
    
      function getId(v) {
        if (Array.isArray(v)) return getId(v[0]);
        if (typeof v === 'object' && v !== null) return getId(v.id);
        return String(v);
      }
    
      const sim = d3.forceSimulation(nodes)
        .force('link',   d3.forceLink(edges).id(d => getId(d.id)).distance(100))
        .force('charge', d3.forceManyBody().strength(-120))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .alphaDecay(0.05)
        .velocityDecay(0.9)
        .alphaMin(0.001);
    
      // tick 
      for (let i = 0; i < 200; ++i) sim.tick();
      sim.stop();
    
      // aviod some nodes don' include coordinates
      nodes.forEach((n, i) => {
        if (typeof n.x !== 'number' || typeof n.y !== 'number') {
          n.x = width  / 2 + 100 * Math.cos(2 * Math.PI * i / nodes.length);
          n.y = height / 2 + 100 * Math.sin(2 * Math.PI * i / nodes.length);
        }
      });
    }





    // Draw the network with automatic scaling
    function getValueRange(nodes, omicsType) {
      const metric = omicsMetric[omicsType] || 'raw';
        const suffix =
        metric === 'zscore' ? 'z'
        : metric === 'norm'   ? 'norm'
        :                       'vals';

      const key = `${omicsType}_${suffix}`;
      let allVals = [];
      nodes.forEach(n => {
        const vals = n[key];
        if (Array.isArray(vals)) {
          allVals = allVals.concat(
            vals.filter(v => typeof v === 'number' && !isNaN(v))
          );
        }
      });
      const min = d3.min(allVals);
      const max = d3.max(allVals);
      return [min, 0, max];
    }

    function updateValueRangeInputs(nodes) {
      const omicsType = d3.select('#omicsType').property('value');
      const [vmin, vzero, vmax] = getValueRange(nodes, omicsType);


      d3.select('#rangeMin').property('value', vmin.toFixed(2));
      d3.select('#rangeMax').property('value', vmax.toFixed(2));

      // omics update scale
      const colorScale = d3.scaleLinear()
        .domain([vmin, vzero, vmax])
        .range([
          d3.select(`#${omicsType}Neg`).property('value'),
          d3.select(`#${omicsType}Zero`).property('value'),
          d3.select(`#${omicsType}Pos`).property('value')
        ]);
      colorConfig[omicsType] = colorScale;
    }

    

    d3.select('#omicsType').on('change', () => {
      const omicsType = d3.select('#omicsType').property('value');
      const metric = omicsMetric[omicsType] || 'raw';
      d3.select('#dataType').property('value', metric);
      if (currentData) {
        updateValueRangeInputs(currentData.nodes);
        updateStyles();
      }
    });

  
   d3.select('#dataType').on('change', () => {
     const omicsType = d3.select('#omicsType').property('value');
     const metric = d3.select('#dataType').property('value');
     omicsMetric[omicsType] = metric;
     if (currentData) {
       updateValueRangeInputs(currentData.nodes);
       updateStyles();
     }
   })
  
  
   function buildNetwork(data) {
     getColorScales();
   
     function getId(v) {
       if (Array.isArray(v)) return getId(v[0]);
       if (typeof v === 'object' && v !== null) return getId(v.id);
       return String(v);
     }
   
     const svg = d3.select('#networkViz');
     container.selectAll('*').remove();
     const width  = +svg.attr('width')  || 1000;
     const height = +svg.attr('height') || 700;
   
     const nodes = data.nodes;
     if (!nodes.length) {
       nodeSel = edgeSelStraight = edgeSelCurved = null;
       return;
     }
   
     const nodeIds  = new Set(nodes.map(d => String(Array.isArray(d.id) ? d.id[0] : d.id)));
     const nodeById = new Map(nodes.map(d => [String(Array.isArray(d.id) ? d.id[0] : d.id), d]));
   
   // First filter edges to the current node set.
     const edges = data.edges
       .map(e => ({
         ...e,
         source: getId(e.source),
         target: getId(e.target)
       }))
       .filter(e => nodeIds.has(e.source) && nodeIds.has(e.target));
   
     // =========================
     // 1. Group multiple edges (by undirected pairs)
     // =========================
     const pairMap = new Map();  // Key = "A|B" (constructed by concatenating sorted A and B)
   
     edges.forEach(e => {
       const key = [e.source, e.target].sort().join('|');  // undirected pair
       if (!pairMap.has(key)) pairMap.set(key, []);
       pairMap.get(key).push(e);
     });
   
     // Annotate each edge with its index within the pair and the total count.
     pairMap.forEach(list => {
       const total = list.length;
       list.forEach((e, idx) => {
         e._idx   = idx;    // 0,1,2,...
         e._total = total;  // total edges of the pair
       });
     });
   
     // Draw edges:
     //   draw multiple edges as curves and single edges as straight lines.
     const straight = edges.filter(d => d._total === 1);
     const curved   = edges.filter(d => d._total > 1);
   
     //edges drew
     edgeSelStraight = container.selectAll('line.edge')
       .data(straight)
       .enter().append('line')
       .attr('class', 'edge')
       .attr('marker-end', 'url(#arrow)');
   
     edgeSelCurved = container.selectAll('path.edge')
       .data(curved)
       .enter().append('path')
       .attr('class', 'edge')
       .attr('fill', 'none')
       .attr('marker-end', 'url(#arrow)');
   
     // draw node group
     const barW = 4, gap = 2;
     const sampleCount = nodes[0].exp_vals.length;
     const angleStep   = 2 * Math.PI / sampleCount;
   
     nodeSel = container.selectAll('g.node')
       .data(nodes)
       .enter().append('g')
       .attr('class', 'node');
   
     nodeSel.call(d3.drag()
       .on('start', (event, d) => {
         d.fx = d.x; d.fy = d.y;
       })
       .on('drag', (event, d) => {
         d.fx = event.x; d.fy = event.y;
         d.x  = event.x; d.y = event.y;
         ticked();
       })
       .on('end', (event, d) => {
         d.fx = d.x; d.fy = d.y;
         const idStr = String(Array.isArray(d.id) ? d.id[0] : d.id);
   
         const idx = lastLayout.findIndex(p => p.id === idStr);
         if (idx >= 0) {
           lastLayout[idx].x = d.x;
           lastLayout[idx].y = d.y;
         } else {
           lastLayout.push({ id: idStr, x: d.x, y: d.y });
         }
   
         const original = data.nodes.find(n => {
           const nid = String(Array.isArray(n.id) ? n.id[0] : n.id);
           return nid === idStr;
         });
         if (original) {
           original.x = d.x;
           original.y = d.y;
         }
   
         if (currentCommId) {
           layoutByCommunity.set(currentCommId, lastLayout.slice());
         }
       })
     );
   
     // =========================
     // 2. ticked: update geometry
     //    - straight edges: standard update
     //    - parallel edges: distribute curvature via a common normal vector and _idx
     // =========================
     function ticked() {
       if (!edgeSelStraight || !edgeSelCurved || !nodeSel) return;
   
       // Straight edges
       edgeSelStraight
         .attr('x1', d => nodeById.get(d.source)?.x ?? 0)
         .attr('y1', d => nodeById.get(d.source)?.y ?? 0)
         .attr('x2', d => nodeById.get(d.target)?.x ?? 0)
         .attr('y2', d => nodeById.get(d.target)?.y ?? 0);
   
       // Curved edges (multiple edges)
       const baseOffset = 20;  // Spacing between edges (can be adjusted as needed)
   
       edgeSelCurved
         .attr('d', d => {
           const s = nodeById.get(d.source);
           const t = nodeById.get(d.target);
           if (!s || !t) return '';
   
           // — Find the undirected pair this edge belongs to —
           const key = [d.source, d.target].sort().join('|');
           const nodesKey = key.split('|');
           const a = nodeById.get(nodesKey[0]); // The "left" node in the undirected pair
           const b = nodeById.get(nodesKey[1]); // The "right" node in the undirected pair
           if (!a || !b) {
             // Fallback: draw as a straight line if anything goes wrong
             return `M${s.x},${s.y} L${t.x},${t.y}`;
           }
   
           // — Compute the normal vector using a unified direction a → b (shared by all edges) —
           const dx  = b.x - a.x;
           const dy  = b.y - a.y;
           const len = Math.sqrt(dx * dx + dy * dy) || 1;
           const nx = -dy / len;   // Common normal vector
           const ny =  dx / len;
   
           // — Distribute parallel edges symmetrically using _idx —
           // eg. total = 2 → k = -0.5, +0.5
           //     total = 3 → k = -1, 0, +1
           const k = d._idx - (d._total - 1) / 2;
           const offset = baseOffset * k;
   
           // Offset the control point from the midpoint of s and t along the normal
           const mx = (s.x + t.x) / 2;
           const my = (s.y + t.y) / 2;
           const cx = mx + nx * offset;
           const cy = my + ny * offset;
   
           return `M${s.x},${s.y} Q${cx},${cy} ${t.x},${t.y}`;
         });
   
       // Node positions
       nodeSel.attr('transform', d => `translate(${d.x},${d.y})`);
     }
   
     ticked();
   
    // Colors and other styles are still handled by the original updateStyles.
     updateStyles();
    }


    function updateStyles() {
      if (!currentData || !nodeSel) return;
      getColorScales();
    
      function getId(v) {
        if (Array.isArray(v)) return getId(v[0]);
        if (typeof v === 'object' && v !== null) return getId(v.id);
        return String(v);
      }
    
      const omicsType = d3.select('#omicsType').property('value');
      const metricForSelected = omicsMetric[omicsType] || 'raw';
      const rmin = +d3.select('#rangeMin').property('value');
      const rmax = +d3.select('#rangeMax').property('value');
    
      // 节点高亮标志
      currentData.nodes.forEach(n => {
        const suffix =
          metricForSelected === 'zscore' ? 'z' :
          metricForSelected === 'norm'   ? 'norm' :
                                           'vals';
        const key = `${omicsType}_${suffix}`;
        const vals = n[key];
        n._highlight = Array.isArray(vals) && vals.some(v => v >= rmin && v <= rmax);
      });
    
      const edgeMetric = d3.select('#edgeMetric').property('value');
      let eMin = +d3.select('#eRangeMin').property('value');
      let eMax = +d3.select('#eRangeMax').property('value');
      if (Number.isFinite(eMin) && Number.isFinite(eMax) && eMin > eMax) [eMin, eMax] = [eMax, eMin];
    
      const toNum = v => {
        if (Array.isArray(v)) v = v[0];
        const n = +v;
        return Number.isFinite(n) ? n : NaN;
      };
    
      const C_NEG  = d3.select('#edgeNeg').property('value')  || '#0000FF';
      const C_ZERO = d3.select('#edgeZero').property('value') || '#FFFFFF';
      const C_POS  = d3.select('#edgePos').property('value')  || '#FF0000';
    
      const negScale = d3.scaleLinear().domain([eMin, 0]).range([C_NEG,  C_ZERO]).clamp(true);
      const posScale = d3.scaleLinear().domain([0,    eMax]).range([C_ZERO, C_POS]).clamp(true);
    
      const allEdges = [...(edgeSelStraight?.data() || []), ...(edgeSelCurved?.data() || [])];
      allEdges.forEach(e => {
        const metW = toNum(e?.[edgeMetric]);
        const rawW = toNum(e?.weight);
        const safeW = Number.isFinite(metW) ? metW : (Number.isFinite(rawW) ? rawW : 0);
        e._w = safeW;
        e._inRange = (safeW >= eMin && safeW <= eMax);
      });
    
      const visibleEdges = allEdges.filter(e => e._inRange);
    
      // interact 模式
      let interactColorById = null;
      let interactOpacityScale = null;
      if (useInteractMode) {
        const filteredEdgesWithId = visibleEdges.filter(e =>
          e.interact_id !== undefined &&
          e.interact_id !== null &&
          e.interact_id !== ''
        );
    
        const ids = Array.from(new Set(filteredEdgesWithId.map(e => e.interact_id)));
        const colorScale = d3.scaleSequential()
          .domain([0, ids.length - 1])
          .interpolator(d3.interpolateRainbow);
    
        interactColorById = new Map();
        ids.forEach((id, i) => {
          interactColorById.set(id, colorScale(i));
        });
    
        const absVals = filteredEdgesWithId.map(e => Math.abs(e._w)).filter(Number.isFinite);
        if (absVals.length) {
          const wMin = d3.min(absVals);
          const wMax = d3.max(absVals);
          interactOpacityScale = d3.scaleLinear()
            .domain([wMin, wMax])
            .range([0.3, 1.0])
            .clamp(true);
        }
      }
    
    const GREY_OUT = '#DDDDDD';
    
    // 基于边的权重决定颜色：负 -> negColor, 0 -> zeroColor, 正 -> posColor
    function baseWeightColor(d) {
      const v = d._w;
      if (!Number.isFinite(v)) return '#CCCCCC';
      if (v === 0) return C_ZERO;
      return v < 0 ? negScale(v) : posScale(v);
    }
    
    // 边的颜色：先看是否在 range 内，再看是否是 interact 模式
    function edgeStroke(d) {
      // 不在数值范围内直接灰掉
      if (!d._inRange) return GREY_OUT;
    
      // interact 模式：用 interact_id 的颜色（如果没有 id，就回退到权重颜色）
      if (useInteractMode) {
        const c = interactColorById?.get(d.interact_id);
        return c || baseWeightColor(d);
      }
    
      // 默认模式：完全按权重上色
      return baseWeightColor(d);
    }
    
    // 边透明度：range 外很淡；interact 模式按权重调透明度；默认给一个较稳定的值
    function edgeOpacity(d) {
      if (!d._inRange) return 0.12;
    
      if (useInteractMode && interactOpacityScale && interactColorById?.has(d.interact_id)) {
        const v = Math.abs(d._w);
        return interactOpacityScale(v);
      }
    
      // 默认模式：给一个中等偏高的透明度
      return 0.7;
    }
    
    
      const maxAbsW = d3.max(visibleEdges, e => Math.abs(e._w)) || 1;
      const sw = v => Math.max(0.5, 1.5 * Math.sqrt(Math.abs(v || 0)));
      const CONST_SW = Math.max(2.5, sw(maxAbsW))*0.75;
    
      if (edgeSelStraight) {
        edgeSelStraight
          .attr('stroke-width', CONST_SW)
          .attr('stroke', d => edgeStroke(d))
          .attr('opacity', d => edgeOpacity(d));
      }
      if (edgeSelCurved) {
        edgeSelCurved
          .attr('stroke-width', CONST_SW)
          .attr('stroke', d => edgeStroke(d))
          .attr('opacity', d => edgeOpacity(d));
      }
    
      // 环 + label 的颜色（和原来 drawNetwork 中的一样）
      nodeSel.each(function(nodeDatum) {
        const omicsTypeSelected = d3.select('#omicsType').property('value');
        const rmin = +d3.select('#rangeMin').property('value');
        const rmax = +d3.select('#rangeMax').property('value');
    
        const barW = 4, gap = 2;
        const sampleCount = nodeDatum.exp_vals.length;
        const angleStep   = 2 * Math.PI / sampleCount;
    
        const ringDefs = [
          { type: 'snv',  inner: barW + gap },
          { type: 'cnv',  inner: 2 * (barW + gap) },
          { type: 'mty',  inner: 3 * (barW + gap) },
          { type: 'exp',  inner: 4 * (barW + gap) },
          { type: 'stage',inner: 5 * (barW + gap) }
        ];
    
        const rings = ringDefs.map(r => {
          if (r.type === 'stage') {
            return { ...r, vals: nodeDatum.stage_idx, scale: null };
          }
          const metric = omicsMetric[r.type] || 'raw';
          const suffix = metric === 'zscore' ? '_z'
                        : metric === 'norm'  ? '_norm'
                        : '_vals';
          return {
            ...r,
            metric,
            vals: nodeDatum[r.type + suffix],
            scale: colorConfig[r.type]
          };
        }).filter(r => Array.isArray(r.vals));
    
        const g = d3.select(this);
    	const currentTransform = g.attr('transform');
        g.selectAll('*').remove();
    
        rings.forEach(ring => {
          const isSelectedOmics = ring.type === omicsTypeSelected;
          const isStage = ring.type === 'stage';
    
          const slices = ring.vals.map((v, i) => ({
            start: i * angleStep,
            end:   (i + 1) * angleStep,
            value: v
          }));
    
          g.selectAll(`path.r${ring.inner}`)
            .data(slices).enter().append('path')
            .attr('d', s => d3.arc()({
              innerRadius: ring.inner,
              outerRadius: ring.inner + barW,
              startAngle: s.start,
              endAngle:   s.end
            }))
            .attr('fill', s => {
              if (s.value == null || isNaN(s.value)) return 'transparent';
              if (!isStage && isSelectedOmics && (s.value < rmin || s.value > rmax)) {
                return '#CCCCCC';
              }
              return isStage ? getStageColorByIndex(s.value) : ring.scale(s.value);
            })
            .attr('fill-opacity', s => {
              if (isStage) return (s.value == null || isNaN(s.value)) ? 0 : 1;
              if (!isSelectedOmics) return 1;
              return (s.value >= rmin && s.value <= rmax) ? 1 : 0.2;
            })
            .attr('stroke-width', isStage ? 0 : (isSelectedOmics ? 0.5 : 0))
            .attr('stroke', s => {
              if (isStage) return 'none';
              if (!isSelectedOmics) return 'none';
              return (s.value >= rmin && s.value <= rmax)
                ? ring.scale(s.value)
                : '#CCCCCC';
            });
        });
    
        g.append('text')
          .text(nodeDatum.id)
          .attr('y', -((4 + 2) * rings.length) - 4)
          .attr('text-anchor', 'middle')
          .style('font-size', '10px')
          .style('pointer-events', 'none');
      });
    }
    
    
    
    
    
    
    
      
     
    d3.select('#filterBtn').on('click', () => {
          updateStyles();
    });  

    // Compute bounding box of container <g> and add padding

    function getContentBBox(padding = 20) {
      const svgNode   = document.getElementById('networkViz');
      if (!svgNode) return null;
    
      const container = svgNode.querySelector('g');   // the <g> element that renders the network
      if (!container) return null;
    
      // 1) Save the current transform
      const oldTransform = container.getAttribute('transform');
    
      // 2) Temporarily remove the transform so getBBox() returns the full layout extent
      if (oldTransform) {
        container.removeAttribute('transform');
      }
    
      // 3) Compute the bounding box in the untransformed coordinate space
      const b = container.getBBox();
    
      // 4) Restore the original transform immediately to avoid affecting the visual state
      if (oldTransform) {
        container.setAttribute('transform', oldTransform);
      }
    
      return {
        x:      b.x - padding,
        y:      b.y - padding,
        width:  b.width  + 2 * padding,
        height: b.height + 2 * padding,
        svg: svgNode,
        container
      };
    }


    // One-click fit: bring all nodes into view (auto-scale to current viewport)
    function fitToView() {
      const info = getContentBBox(40);
      if (!info) return;
      const svg = d3.select(info.svg);
      const width  = +svg.attr('width')  || 1000;
      const height = +svg.attr('height') || 700;
    
      const scale = Math.min(width / info.width, height / info.height) * 0.95;
      const tx = width  / 2 - scale * (info.x + info.width  / 2);
      const ty = height / 2 - scale * (info.y + info.height / 2);
      const t = d3.zoomIdentity.translate(tx, ty).scale(scale);
    
      if (window.zoomBehavior) {
        svg.transition().duration(300)
           .call(window.zoomBehavior.transform, t)
           .selection()
           .on('wheel.zoom', null)
           .on('dblclick.zoom', null)
           //.on('mousedown.zoom', null)
           //.on('touchstart.zoom', null);
      } else {
        d3.select(info.container)
          .attr('transform', `translate(${tx},${ty}) scale(${scale})`);
      }
    
    }
    

    function snapshotSVG() {
      const svgOriginal = document.getElementById('networkViz');
      if (!svgOriginal) return null;
    
      // Use the previously defined function to get the content bounding box
      // (independent of scrolling and zoom transformations)
      const info = getContentBBox(40);   // Apply a padding of 40 (adjustable as needed)
    
      // Clone the current SVG (used for export only; modifications will not affect the live view)
      const svgNode = svgOriginal.cloneNode(true);
      svgNode.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      svgNode.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
      svgNode.removeAttribute('style');  
    
      // Remove zoom/pan transforms from the <g> elements in the cloned SVG
      // so the original layout coordinates are used
      const gClone = svgNode.querySelector('g');
      if (gClone) {
        gClone.removeAttribute('transform');
      }
    
      let w, h, vx, vy;
      if (info) {
        w  = info.width;
        h  = info.height;
        vx = info.x;
        vy = info.y;
      } else {
        // Fallback: if no bounding box info is available, revert to the original logic
        if (svgOriginal.viewBox && svgOriginal.viewBox.baseVal && svgOriginal.viewBox.baseVal.width) {
          w = svgOriginal.viewBox.baseVal.width;
          h = svgOriginal.viewBox.baseVal.height;
        } else {
          w = svgOriginal.width.baseVal.value || 1000;
          h = svgOriginal.height.baseVal.value || 700;
        }
        vx = 0;
        vy = 0;
      }
    
      // Set the viewBox to fully cover the content area
      svgNode.setAttribute('viewBox', `${vx} ${vy} ${w} ${h}`);
      svgNode.setAttribute('width',  w);
      svgNode.setAttribute('height', h);
    
      // Note: do not modify marker#arrow here; keep it consistent with the on-screen rendering
      return svgNode;
    }



    // download SVG
    function saveSVG() {
      const svgNode = snapshotSVG();
      if (!svgNode) return;
      const ser = new XMLSerializer();
      const svgStr = ser.serializeToString(svgNode);
      const blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const id = d3.select('#commSelect').property('value') || 'community';
      const a = document.createElement('a');
      a.href = url;
      a.download = `${id}.svg`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

 
    async function savePDF() {
      const svgNode = snapshotSVG();
      if (!svgNode) return;
    
      const w = svgNode.viewBox?.baseVal?.width  || svgNode.width.baseVal.value;
      const h = svgNode.viewBox?.baseVal?.height || svgNode.height.baseVal.value;
    
      const PDFCtor = (window.jsPDF || (window.jspdf && window.jspdf.jsPDF));
      if (!PDFCtor) {
        alert('jsPDF 没有正确加载');
        return;
      }
    
      // Support multiple export paths; prefer svg2pdfFn registered in <head>
      const svg2pdfFn =
        (typeof window.svg2pdfFn === 'function') ? window.svg2pdfFn :
        (typeof window.svg2pdf    === 'function') ? window.svg2pdf    :
        null;
    
      if (!svg2pdfFn) {
        alert('svg2pdf.js 没有正确加载');
        return;
      }
    
      const pdf = new PDFCtor({
        orientation: w > h ? 'l' : 'p',
        unit: 'pt',
        format: [w, h]
      });
    
      // use  svg2pdf to create vector-based PDF
      await svg2pdfFn(svgNode, pdf, {
        xOffset: 0,
        yOffset: 0,
        scale:   1,
        useCSS:  true
      });
    
      const id = d3.select('#commSelect').property('value') || 'community';
      pdf.save(`${id}.pdf`);
    }



    const zoomStep = 1.2; 
    
    const btnIn  = document.getElementById('zoomIn');
    const btnOut = document.getElementById('zoomOut');
    
    if (btnIn) {
      btnIn.addEventListener('click', () => {
        if (!window.zoomBehavior) return;
        svg.transition().duration(250)
           .call(window.zoomBehavior.scaleBy, zoomStep);
      });
    }
    
    if (btnOut) {
      btnOut.addEventListener('click', () => {
        if (!window.zoomBehavior) return;
        svg.transition().duration(250)
           .call(window.zoomBehavior.scaleBy, 1 / zoomStep);
      });
    }


    //build session
    function buildSessionJSON() {
      const sid = new URLSearchParams(location.search).get('sid') || '';
    
      const state = {
        sid,
        community: d3.select('#commSelect').property('value'),
        degreeRange: {
          min: +d3.select('#degMin').property('value'),
          max: +d3.select('#degMax').property('value')
        },
        dataFilter: {
          dataType:  d3.select('#dataType').property('value'),
          omicsType: d3.select('#omicsType').property('value'),
          valueRange: {
            min: +d3.select('#rangeMin').property('value'),
            max: +d3.select('#rangeMax').property('value')
          }
        },
        edgeFilter: {
          metric: d3.select('#edgeMetric').property('value'),
          range: {
            min: +d3.select('#eRangeMin').property('value'),
            max: +d3.select('#eRangeMax').property('value')
          }
        },
        colors: {
          exp: { neg: d3.select('#expNeg').property('value'), zero: d3.select('#expZero').property('value'), pos: d3.select('#expPos').property('value') },
          mty: { neg: d3.select('#mtyNeg').property('value'), zero: d3.select('#mtyZero').property('value'), pos: d3.select('#mtyPos').property('value') },
          snv: { neg: d3.select('#snvNeg').property('value'), zero: d3.select('#snvZero').property('value'),pos: d3.select('#snvPos').property('value')},
          cnv: { neg: d3.select('#cnvNeg').property('value'), zero: d3.select('#cnvZero').property('value'), pos: d3.select('#cnvPos').property('value') },
          edge:{ neg: d3.select('#edgeNeg').property('value'), zero: d3.select('#edgeZero').property('value'), pos: d3.select('#edgePos').property('value') }
        },
        // display the subset of data
        data: (typeof currentData !== 'undefined' && currentData) ? {
          nodes: currentData.nodes,
          edges: currentData.edges
        } : null,
    
        //the latest point coordinate from last time
        layout: lastLayout,
    
        // json path with ssession id
        source: sid ? `uploads/${sid}/community_map_top100.json` : 'uploads/community_map_top100.json',
    
        savedAt: new Date().toISOString()
      };
      return state;
    }
    
    /* trigger the downloading*/
    function saveJSON() {
      const state = buildSessionJSON();
      const text  = JSON.stringify(state, null, 2);
      const blob  = new Blob([text], { type: 'application/json;charset=utf-8' });
      const url   = URL.createObjectURL(blob);
    
      const sid  = state.sid || 'nosid';
      const comm = state.community || 'community';
    
      const a = document.createElement('a');
      a.href = url;
      a.download = `session_${sid}_${comm}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

/* =====bind the button ===== */
   const saveJSONBtn = document.getElementById('saveJSONBtn');
   if (saveJSONBtn) saveJSONBtn.onclick = () => saveJSON();
   	    
   
   
    })();
  </script>
</body>
</html>
