<!DOCTYPE html>
<html lang="en-US">
<head>
	<meta charset="UTF-8">
	<title>Multi-omics Visulization</title>
	<script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <!-- svg2pdf 统一用 2.6.0 UMD 版本 -->
    <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.6.0/dist/svg2pdf.umd.min.js"></script>

    <script>
    // Normalize the jsPDF constructor and expose it consistently
    window.jsPDF = window.jspdf && window.jspdf.jsPDF;

    // Standardize the svg2pdf export function as window.svg2pdfFn / window.svg2pdf
    (function () {
      var lib = window.svg2pdf;   // Note: the UMD build exports an object rather than a single function
      var fn  = null;

      if (typeof lib === 'function') {
        fn = lib;
      } else if (lib && typeof lib.svg2pdf === 'function') {
        fn = lib.svg2pdf;
      } else if (lib && typeof lib.default === 'function') {
        fn = lib.default;
      }

      if (fn) {
        window.svg2pdfFn = fn;
        window.svg2pdf   = fn;
      }
    })();
	</script>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
    }
    #controls {
      padding: 10px;
      background: #f7f7f7;
      border-bottom: 1px solid #ddd;
      position: fixed; /* stick on the top  */
      top: 0; left: 0; right: 0;
      min-height: 100px;    
      z-index: 100;
    }

    #controls label, #controls div {
      margin-right: 20px;
      display: inline-block;
      vertical-align: middle;
    }
    #controls input[type="color"] {
      width: 24px;
      height: 24px;
      padding: 0;
      border: none;
      margin-left: 4px;
      vertical-align: middle;
    }
    /********************************************/
    #networkContainer {
     position: absolute;
     top: 100px; left: 0; right: 0; bottom: 0;
     overflow: auto;      /* can always roll */
     background: white;

    
    }

    #networkViz {
      display: block;
      width: 700%;    /*  2 times wider than initial width */
      height: 700%;   /*  2 times wider than initial width */
      background: white;
	  cursor: grab;  
    }
	#networkViz:active {
     cursor: grabbing;    /* 鼠标按下时 */
   }
    #zoomControls {
      position: fixed;
      top: 120px;
      right: 20px;
      z-index: 200;
    }

    #zoomControls button {
      display: block;
      margin-bottom: 5px;
      font-size: 18px;
      width: 40px;
      height: 40px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label>
      Network：
      <select id="commSelect"></select>
    </label>
    <label>
      Degree Range：
      <input type="number" id="degMin" value="0" min="0" max="500" style="width:60px;">
      –
      <input type="number" id="degMax" value="500" min="0" max="500" style="width:60px;">
       <button id="fitBtn">Fit</button>
       <button id="saveSVGBtn">Save SVG</button>
       <button id="savePDFBtn">Save PDF</button>
       <button id="saveJSONBtn">Save JSON</button>

     </label>
     <br> 
     <div id="colorPickers" style="margin-top:8px;">
	  <span>Data1：</span>
	  <input type="color" id="expNeg" value="#0000FF" title="Exp Negative" />
	  <input type="color" id="expZero" value="#F7F7F7" title="Exp Zero" />
	  <input type="color" id="expPos" value="#FF0000" title="Exp Positive" />
      <span style="display:inline-block; width:30px;"></span>  
      <span>Data2：</span>
      <input type="color" id="mtyNeg" value="#0000FF" title="Mty Negative" />
      <input type="color" id="mtyZero" value="#F7F7F7" title="Mty Zero" />
      <input type="color" id="mtyPos" value="#FF0000" title="Mty Positive" />
      <span style="display:inline-block; width:30px;"></span> 
      <span>Data3：</span>
      <input type="color" id="cnvNeg" value="#0000FF" title="CNV Negative" />
      <input type="color" id="cnvZero" value="#F7F7F7" title="CNV Zero" />
      <input type="color" id="cnvPos" value="#FF0000" title="CNV Positive" />
      <span style="display:inline-block; width:30px;"></span>
      <span>Data4：</span>
      <input type="color" id="snvNeg"  value="#0000FF" title="SNV Negative" />
      <input type="color" id="snvZero" value="#F7F7F7" title="SNV Zero" />    
      <input type="color" id="snvPos"  value="#FF0000" title="SNV Positive" />
      <br>
    </div>  
    <br>
    <div style="display:inline-block; margin-top:0; vertical-align:middle;">
     <label>
       Data:
       <select id="omicsType">
        <option value="exp">Data1</option>
        <option value="mty">Data2</option>
        <option value="cnv">Data3</option>
        <option value="snv">Data4</option>
       </select>
      </label>
     <label>
       Data Norm:
      <select id="dataType">
        <option value="raw">Raw</option>
        <option value="norm">Min-Max norm</option>
        <option value="zscore">Z-score</option>
       </select>
      </label>
      <label>

     <label>
       Value Range:
        <input type="number" id="rangeMin" value="-1" step="0.1" style="width:60px;"> -
        <input type="number" id="rangeMax" value="1" step="0.1" style="width:60px;">
     </label>
       <button id="filterBtn">Filter</button>
     </div>
     <br>
     <div class="legend-row" style="margin-top:8px;">
       <span>Group：</span>
       <span id="stageLegend" class="legend-inline"></span>
     </div>
    <br>
    <div>
      <span>Edges：</span>
      Negative: <input type="color" id="edgeNeg" value="#00FF00" title="Negative weight" />
      Zero: <input type="color" id="edgeZero" value="#FFFFFF" title="Zero weight" />
      Postive: <input type="color" id="edgePos" value="#FF00FF" title="Postive Weight" />
     </div>
  <br>
  <div style="margin-top:8px;">
    <span>Edge Data Norm:</span>
    <select id="edgeMetric">
     <option value="w_raw">Raw</option>
     <option value="w_norm">Min-Max Norm</option>
     <option value="w_z">Z-score</option>
    </select>
    <label style="margin-left:12px;">
      Range:
     <input type="number" id="eRangeMin" value="-1" step="0.1" style="width:80px;">
      –
     <input type="number" id="eRangeMax" value="1"  step="0.1" style="width:80px;">
    </label>
    <button id="edgeFilterBtn">Filter edges</button>
	<label style="margin-left:12px;">
      <input type="checkbox" id="useInteract">
      color by interact_id
    </label>
  </div>


  </div>
    
  <!-- zoom control item displaying on the right -->
	<div id="zoomControls">
	  <button id="zoomIn">➕</button>
	  <button id="zoomOut">➖</button>
	</div>
   
  
  
   <div id="networkContainer">
     <svg id="networkViz">
        
    </svg>
        
    </div>
  
  <script>
  (function(){
    
    let currentData = null;
    let lastLayout = []; 
	let layoutByCommunity = new Map(); // Store the layout separately for each community
    let currentCommId = null;         // The currently selected community ID
    const viewWidth  = window.innerWidth;
    const viewHeight = window.innerHeight - 100;  

    // set SVG in standard size
    const svg = d3.select('#networkViz')
      .attr('width',  viewWidth)
      .attr('height', viewHeight);
    let container = null;   // reference to the <g> container
    let zoom      = null;   // reference to the zoom behavior
    let colorConfig = {};
    let currentTransform = d3.zoomIdentity; 
    const zoomStep = 1.2;
    const btnIn  = document.getElementById('zoomIn');
    const btnOut = document.getElementById('zoomOut');
    
    if (btnIn) {
      btnIn.addEventListener('click', () => {
        if (!zoom) return;                // Guard against rendering before the data is fully initialized
        currentTransform = currentTransform.scale(zoomStep);
        svg.transition().duration(250)
           .call(zoom.transform, currentTransform);
      });
    }
    
    if (btnOut) {
      btnOut.addEventListener('click', () => {
        if (!zoom) return;
        currentTransform = currentTransform.scale(1 / zoomStep);
        svg.transition().duration(250)
           .call(zoom.transform, currentTransform);
      });
    }
    // Per-omics metric mode: raw / norm / zscore
    const METRICS = ['raw', 'norm', 'zscore'];
    let omicsMetric = {
      exp: 'raw',
      mty: 'raw',
      snv: 'raw',
      cnv: 'raw'
    };
	    function getColorScales() {
	      // gene expression
	      colorConfig.exp = d3.scaleLinear()
	        .domain([-1, 0, 1])
	        .range([
	          d3.select('#expNeg').property('value'),
	          d3.select('#expZero').property('value'),
	          d3.select('#expPos').property('value')
	        ]);
	
	      // methylation
	      colorConfig.mty = d3.scaleLinear()
	        .domain([-1, 0, 1])
	        .range([
	          d3.select('#mtyNeg').property('value'),
	          d3.select('#mtyZero').property('value'),
	          d3.select('#mtyPos').property('value')
	        ]);
	
	      // Single Nucleotide Variant
              colorConfig.snv = d3.scaleLinear()
                 .domain([-1, 0, 1])
                 .range([
                      d3.select('#snvNeg').property('value'),
                      d3.select('#snvZero').property('value'),
                      d3.select('#snvPos').property('value')
              ]);	
	      // copy number variation 
	      colorConfig.cnv = d3.scaleLinear()
	        .domain([-1, 0, 1])
	        .range([
	          d3.select('#cnvNeg').property('value'),
	          d3.select('#cnvZero').property('value'),
	          d3.select('#cnvPos').property('value')
	        ]);
	
	      // edge
	      colorConfig.edge = {
	        neg:  d3.select('#edgeNeg').property('value'),
	        zero: d3.select('#edgeZero').property('value'),
	        pos:  d3.select('#edgePos').property('value')
	      };
	    }
	
	
	    const DEFAULT_STAGE_COLORS = [
	      '#1f77b4', // 0
	      '#d62728', // 1
	      '#2ca02c', // 2
	      '#ffbf00', // 3
	      '#9467bd', // 4
	      '#ff7f0e'  // 5
	    ];
	
	  const STAGE_IDS = [0,1,2,3,4,5];
	  const stageColorMap = new Map(STAGE_IDS.map(i => [i, DEFAULT_STAGE_COLORS[i]]));
	
	
	function setStageColor(i, hex) {
	  if (!Number.isInteger(i) || i < 0) return;
	  if (/^#[0-9A-Fa-f]{6}$/.test(hex)) stageColorMap.set(i % STAGE_IDS.length, hex);
	}
	function getStageColorByIndex(v) {
	  const n = Number(v);
	  if (!Number.isFinite(n)) return 'transparent';
	  const i = Math.floor(n);
	  if (i < 0) return 'transparent'; // if data=-1,it can be transparent
	  const k = i % STAGE_IDS.length;
	  return stageColorMap.get(k) || DEFAULT_STAGE_COLORS[k];
	}
	
	
	 
	
	function renderStageLegend() {
	  const container = d3.select('#stageLegend');
	  if (container.empty()) return;
	
	  container.selectAll('*').remove();
	
	  const wrap = container.append('div')
	    .style('display','inline-flex')
	    .style('gap','14px')
	    .style('align-items','center')
	    .style('flex-wrap','wrap');
	
	  // calculate the live group existing in community
	  const present = new Set();
	  if (currentData?.nodes?.length) {
	    currentData.nodes.forEach(n => {
	      const arr = Array.isArray(n.stage_idx) ? n.stage_idx : [];
	      arr.forEach(v => {
	        const x = Math.floor(+v);
	        if (Number.isFinite(x) && x >= 0) present.add(x % STAGE_IDS.length);
	      });
	    });
	  }
	
	  STAGE_IDS.forEach(i => {
	    const hasData = present.has(i);
	    const color = stageColorMap.get(i) || DEFAULT_STAGE_COLORS[i];
	
	    const row = wrap.append('label')
	      .style('display','inline-flex')
	      .style('align-items','center')
	      .style('gap','8px');
	
	    row.append('span')
	      .text(`group ${i}`)
	      .style('opacity', hasData ? 1 : 0.45);
	
	    row.append('input')
	      .attr('type','color')
	      .attr('id', `stageColor-${i}`)
	      .attr('value', color)
	      .property('value', color)
	      .property('disabled', !hasData)               // no data will be forbidden
	      .style('width','28px')                        
	      .style('height','28px')
	      .style('padding','0')
	      .style('border','1px solid #ccc')
	      .style('cursor', hasData ? 'pointer' : 'not-allowed')
	      // visulization
	      .style('filter', hasData ? null : 'grayscale(100%) brightness(0.85)')
	      .style('opacity', hasData ? 1 : 0.7)
	      .on('input', function () {
	        if (!hasData) return;
	        setStageColor(i, this.value);
	        if (currentData) drawNetwork(currentData);
	      })
	      .on('change', function () {
	        if (!hasData) return;
	        setStageColor(i, this.value);
	        if (currentData) drawNetwork(currentData);
	      });
	  });
	}

  //load json file

	  const sid = new URLSearchParams(location.search).get('sid') || '';
	  const jsonPath = sid ? `uploads/${sid}/community_map_top100.json`: 'uploads/community_map_top100.json';
	  fetch(jsonPath)
	   .then(r => r.json())
	   .then(json => {
	    const dataArr = Array.isArray(json) ? json : Object.values(json);
	    window.allCommunities = dataArr;
	    const sel = d3.select('#commSelect');
	    /* drop-down menu */
	    dataArr.forEach(item => {
	      sel.append('option')
	         .attr('value', item.comm)
	         .text(`Network ${item.comm}`);
	    });
	
	
	    sel.property('value', dataArr[0].comm);
	    getColorScales();
	    sel.on('change', renderCommunity);
	    renderCommunity();                // initial render
	
	    d3.selectAll('#degMin, #degMax').on('change', renderCommunity); 
	  
	    // Color picker change → redraw immediately 
	   d3.selectAll('#colorPickers input[type="color"]').on('input', () => {
	    getColorScales();
	    if (currentData) drawNetwork(currentData);
	   });
	    d3.selectAll('#edgeNeg, #edgeZero, #edgePos').on('input', () => {
	      getColorScales();
	      if (currentData) drawNetwork(currentData);
	   });
	
	
	     // Edge metric switch (Raw/Norm/Z) → reset range + redraw
	    d3.select('#edgeMetric').on('change', () => {
	      if (!currentData) return;
	      setEdgeRangeInputs(currentData.edges);  // Reset eRangeMin/eRangeMax based on the new metric
	      drawNetwork(currentData);
	    });
	
	    // Edge range input change → redraw
	    d3.selectAll('#eRangeMin, #eRangeMax').on('change', () => {
	      if (currentData) drawNetwork(currentData);
	    });
	
	    // 'Filter edges' button → redraw
	    d3.select('#edgeFilterBtn').on('click', () => {
	      if (currentData) drawNetwork(currentData);
	    });
		d3.select('#useInteract').on('change', () => {
          if (currentData) drawNetwork(currentData);
        });
	    const fitBtn = document.getElementById('fitBtn');
	    if (fitBtn) fitBtn.onclick = () => fitToView();
	
	    const saveSVGBtn = document.getElementById('saveSVGBtn');
	    if (saveSVGBtn) saveSVGBtn.onclick = () => saveSVG();
	
	    const savePDFBtn = document.getElementById('savePDFBtn');
	    if (savePDFBtn) savePDFBtn.onclick = () => savePDF();
	
		     })
	  .catch(err => console.error('JSON loading failed:', err));
	
	
	
	function setEdgeRangeInputs(edges) {
	  const metric = d3.select('#edgeMetric').property('value');
	  const toNum = v => {
	    if (Array.isArray(v)) v = v[0];
	    const n = +v;
	    return Number.isFinite(n) ? n : NaN;
	  };
	  const vals = edges
	    .map(e => toNum((e && e[metric]) ?? e?.weight))
	    .filter(Number.isFinite);
	
	  if (!vals.length) return;
	
	  let emin = d3.min(vals), emax = d3.max(vals);
	  if (emin === emax) {
	    const pad = Math.max(1e-6, Math.abs(emin) * 0.01 || 0.01);
	    emin -= pad; emax += pad;
	  }
	  d3.select('#eRangeMin').property('value', emin.toFixed(3));
	  d3.select('#eRangeMax').property('value', emax.toFixed(3));
	}			    


    // render the specific communtiy
  
    function renderCommunity() {
      const id = d3.select('#commSelect').property('value');
      let dmin = +d3.select('#degMin').property('value');
      let dmax = +d3.select('#degMax').property('value');
      if (Number.isFinite(dmin) && Number.isFinite(dmax) && dmin > dmax) {
        [dmin, dmax] = [dmax, dmin];
      }
    
     // Utility: retrieve a normalized string ID
      if (currentCommId && lastLayout.length) {
        layoutByCommunity.set(currentCommId, lastLayout.slice());
      }
      currentCommId = id;
    
      const raw = window.allCommunities.find(d => String(d.comm) === id);
      if (!raw) {
        console.warn('community does not exist:', id);
        return;
      }
    
      // Helper function: obtain a unified string identifier
      function getId(v) {
        if (Array.isArray(v)) return getId(v[0]);
        if (typeof v === 'object' && v !== null) return getId(v.id);
        return String(v);
      }
    
      const nodesById = new Map(
        raw.nodes.map(n => [getId(n.id), n])
      );
    
      //Core nodes: nodes whose degree falls within [dmin, dmax]
      const inRangeIds = new Set(
        raw.nodes
          .filter(n => n.degree >= dmin && n.degree <= dmax)
          .map(n => getId(n.id))
      );
    
      //  Core nodes: nodes with degree in the range [dmin, dmax]
      const highNeighborIds = new Set();
    
      raw.edges.forEach(e => {
        const sId = getId(e.source);
        const tId = getId(e.target);
        const sNode = nodesById.get(sId);
        const tNode = nodesById.get(tId);
        if (!sNode || !tNode) return;
    
        const sIn = inRangeIds.has(sId);
        const tIn = inRangeIds.has(tId);
    
        if (sIn && tNode.degree > dmax) highNeighborIds.add(tId);
        if (tIn && sNode.degree > dmax) highNeighborIds.add(sId);
      });
    
      // High-order neighbors: nodes with degree greater than dmax
      const usedIdSet = new Set([...inRangeIds, ...highNeighborIds]);
    
      const nodesUsed = raw.nodes.filter(n => {
        const nid = getId(n.id);
        return usedIdSet.has(nid);
      });
    
      //   and at least one edge connecting them to a core node
      const edgesUsed = raw.edges.filter(e => {
        const sId = getId(e.source);
        const tId = getId(e.target);
        if (!usedIdSet.has(sId) || !usedIdSet.has(tId)) return false;
        return inRangeIds.has(sId) || inRangeIds.has(tId);
      });
    
      const data = { nodes: nodesUsed, edges: edgesUsed };
    
      //If this community has been rendered before, overwrite x/y with the cached layout.
      const savedLayout = layoutByCommunity.get(id);
      if (savedLayout && savedLayout.length) {
        const layoutMap = new Map(savedLayout.map(p => [String(p.id), p]));
        data.nodes.forEach(n => {
          const nid = getId(n.id);
          const p = layoutMap.get(nid);
          if (p) {
            n.x = p.x;
            n.y = p.y;
          }
        });
      }
    
      currentData = data;
      updateValueRangeInputs(data.nodes);
      renderStageLegend();
      setEdgeRangeInputs(data.edges);
      drawNetwork(data);
    }






    // Draw the network with automatic scaling
    function getValueRange(nodes, omicsType) {
      const metric = omicsMetric[omicsType] || 'raw';
        const suffix =
        metric === 'zscore' ? 'z'
        : metric === 'norm'   ? 'norm'
        :                       'vals';

      const key = `${omicsType}_${suffix}`;
      let allVals = [];
      nodes.forEach(n => {
        const vals = n[key];
        if (Array.isArray(vals)) {
          allVals = allVals.concat(
            vals.filter(v => typeof v === 'number' && !isNaN(v))
          );
        }
      });
      const min = d3.min(allVals);
      const max = d3.max(allVals);
      return [min, 0, max];
    }

    function updateValueRangeInputs(nodes) {
      const omicsType = d3.select('#omicsType').property('value');
      const [vmin, vzero, vmax] = getValueRange(nodes, omicsType);


      d3.select('#rangeMin').property('value', vmin.toFixed(2));
      d3.select('#rangeMax').property('value', vmax.toFixed(2));

      // update  scale color of omics
      const colorScale = d3.scaleLinear()
        .domain([vmin, vzero, vmax])
        .range([
          d3.select(`#${omicsType}Neg`).property('value'),
          d3.select(`#${omicsType}Zero`).property('value'),
          d3.select(`#${omicsType}Pos`).property('value')
        ]);
      colorConfig[omicsType] = colorScale;
    }

    
    // add listener to monitor the change
    // Switching Data1–Data4 synchronizes the dataType and triggers a redraw.
    d3.select('#omicsType').on('change', () => {
      const omicsType = d3.select('#omicsType').property('value');  // exp/mty/snv/cnv
      const metric = omicsMetric[omicsType] || 'raw';

      // Sync the Data Norm dropdown to this DataX's own setting.
      d3.select('#dataType').property('value', metric);

      if (currentData) {
        updateValueRangeInputs(currentData.nodes);
        drawNetwork(currentData);
      }
    });

    // When changing Data Norm (Raw / Norm / Z-score):
    //   only affects the currently selected DataX.
    d3.select('#dataType').on('change', () => {
      const omicsType = d3.select('#omicsType').property('value');       // current DataX
      const metric = d3.select('#dataType').property('value');           // raw / norm / zscore

      // Only change the mode of this omics; all others remain unchanged.
      omicsMetric[omicsType] = metric;

      if (currentData) {
        updateValueRangeInputs(currentData.nodes);
        drawNetwork(currentData);
      }
    });
  
  
       
     function drawNetwork(data) {
     
           
           getColorScales(); 
     
           function getId(v) {
             if (Array.isArray(v)) return getId(v[0]);
             if (typeof v === 'object' && v !== null) return getId(v.id);
             return String(v);
           }
     
           // Currently selected DataX (exp / mty / snv / cnv)
           const omicsType = d3.select('#omicsType').property('value');
           // The metric of this DataX itself (raw / norm / z-score)
           const metricForSelected = omicsMetric[omicsType] || 'raw';
     
           const rmin = +d3.select('#rangeMin').property('value');
           const rmax = +d3.select('#rangeMax').property('value');
     
           // Use the current DataX together with its metric to control highlighting
           data.nodes.forEach(n => {
             const suffix =
             metricForSelected === 'zscore' ? 'z'
             : metricForSelected === 'norm'   ? 'norm'
             :                                 'vals';
     
     	const key = `${omicsType}_${suffix}`;
             const vals = n[key];
             n._highlight = Array.isArray(vals) && vals.some(v => v >= rmin && v <= rmax);
           });
 
      const svgSel = d3.select('#networkViz');
       svgSel.selectAll('*').remove();
     
       container = svgSel.append("g");
     
       zoom = d3.zoom()
         .filter(e =>
           e.type === "mousedown"   ||
           e.type === "mousemove"   ||
           e.type === "touchstart"
         )
         .on("zoom", e => {
           currentTransform = e.transform;
           container.attr("transform", currentTransform);
         });
     
       svgSel.call(zoom)
             .call(zoom.transform, currentTransform)
             .on("wheel.zoom", null);
     
       const width = +svg.attr("width") || 1000;
       const height = +svg.attr("height") || 700;
     
       //  Clone nodes/edges and filter out dangling edges
       const nodes = data.nodes.map(d => {
       const copy = Object.assign({}, d);
       const idStr = String(Array.isArray(copy.id) ? copy.id[0] : copy.id);
       const p = lastLayout.find(p => p.id === idStr);
       if (p) {
         copy.x = p.x;
         copy.y = p.y;
       }
       return copy;
       });
       const nodeIds = new Set(nodes.map(d => String(Array.isArray(d.id) ? d.id[0] : d.id)));
       const nodeById = new Map(nodes.map(d => [String(Array.isArray(d.id) ? d.id[0] : d.id), d]));
       console.log('nodeById keys:', Array.from(nodeById.keys()));
       const firstId = Array.isArray(nodes[0].id) ? nodes[0].id[0] : nodes[0].id;      
       const id2 = Array.isArray(nodes[1].id) ? nodes[1].id[0] : nodes[1].id;
       const id6 = Array.isArray(nodes[5].id) ? nodes[5].id[0] : nodes[5].id;
     
       

       
     const edgeMetric = d3.select('#edgeMetric').property('value'); // 'w_raw' | 'w_norm' | 'w_z'
     let eMin = +d3.select('#eRangeMin').property('value');
     let eMax = +d3.select('#eRangeMax').property('value');
     
     // Swap min and max if the user enters them in reverse order.
     if (Number.isFinite(eMin) && Number.isFinite(eMax) && eMin > eMax) {
       [eMin, eMax] = [eMax, eMin];
     }
     
     const toNum = v => {
       if (Array.isArray(v)) v = v[0];
       const n = +v;
       return Number.isFinite(n) ? n : NaN;
     };
     
     // Core: use the sorted "A|B" as the key to merge A→B and B→A into a single undirected edge.
     const edgeMap = new Map();
     
     data.edges.forEach(e => {
       const s = getId(e.source);
       const t = getId(e.target);
     
       //  Drop edges if either node is not in the current subgraph.
       if (!nodeIds.has(s) || !nodeIds.has(t)) return;
     
       const key = [s, t].sort().join('|');  // undirected key
     
       const metW = toNum(e?.[edgeMetric]);
       const rawW = toNum(e?.weight);
       const safeW = Number.isFinite(metW) ? metW : (Number.isFinite(rawW) ? rawW : 0);
     
       const existed = edgeMap.get(key);
      if (!existed) {
         edgeMap.set(key, {
           source: s,
           target: t,
           rawSum: Number.isFinite(rawW) ? rawW : 0,
           metSum: Number.isFinite(safeW) ? safeW : 0,
           count: 1,
           interact_id: e.interact_id
         });
       } else {
         if (Number.isFinite(rawW)) existed.rawSum += rawW;
         if (Number.isFinite(safeW)) existed.metSum += safeW;
         existed.count += 1;
     
         }
     });
     

     
     
       const edges = Array.from(edgeMap.values()).map(e => {
       const avgRaw = e.rawSum / e.count;
       const avgMet = e.metSum / e.count;
     
       return {
         source: e.source,
         target: e.target,
         weight: avgRaw,
         _w: avgMet,
         interact_id: e.interact_id,
         _inRange: avgMet >= eMin && avgMet <= eMax
       };
     });
     
     const maxWeight = d3.max(edges, d => Math.abs(d._w) || 0.01);
     // If coloring by interact_id is enabled
     const useInteractColor = d3.select('#useInteract')?.property('checked');
     
     let interactColorById = new Map();
     if (useInteractColor) {
       const visibleEdges = edges.filter(e => e._inRange && e.interact_id);
       const uniqueInteractIds = Array.from(new Set(visibleEdges.map(e => e.interact_id)));
     
       const colorScale = d3.scaleOrdinal()
         .domain(uniqueInteractIds)
         .range(d3.schemeCategory10.concat(d3.schemeSet3));
     
        interactColorById = new Map(uniqueInteractIds.map(id => [id, colorScale(id)]));
 
     }
     
     		  
     
     
     const C_NEG  = d3.select('#edgeNeg').property('value')  || '#0000FF';
     const C_ZERO = d3.select('#edgeZero').property('value') || '#FFFFFF'; // 0=white
     const C_POS  = d3.select('#edgePos').property('value')  || '#FF0000';
     
     const negScale = d3.scaleLinear().domain([eMin, 0]).range([C_NEG,  C_ZERO]).clamp(true);
     const posScale = d3.scaleLinear().domain([0,    eMax]).range([C_ZERO, C_POS]).clamp(true);
     
     function edgeColor(d) {
       if (!d._highlight || !d._inRange) return '#CCCCCC';
     
       if (useInteractColor) {
         const base = d3.color(interactColorById.get(d.interact_id) || '#000000');
         const weight = Math.abs(d._w); 
         const normWeight = Math.min(1, weight / maxWeight); 
         base.opacity = 0.2 + 0.8 * normWeight; 
         return base + '';
       }
     
       // Color by weight by default
       const v = d._w;
       if (!Number.isFinite(v)) return '#CCCCCC';
       if (v === 0) return C_ZERO;
       return v < 0 ? negScale(v) : posScale(v);
     }
     
     
     
     const maxAbsW = d3.max(edges, e => Math.abs(e._w)) || 1;
     const sw = v => Math.max(0.5, 1.5 * Math.sqrt(Math.abs(v || 0)));
     const CONST_SW = Math.max(2.5, sw(maxAbsW));
     
     
     
      // Mark edges with _highlight based on the highlight status of their endpoints
       edges.forEach(e => {
         const s = nodeById.get(e.source);
         const t = nodeById.get(e.target);
         e._highlight = s && t && s._highlight && t._highlight;
       });
     
       // For undirected graphs, all edges are rendered as straight lines
       const straight = edges;
     
     
       //  Force simulation
       // Preserve initial layout if historical positions exist
       nodes.forEach((d, i) => {
       // If x/y are [values], extract numeric values
       if (Array.isArray(d.x) && d.x.length === 1) {
         d.x = d.x[0];
       }
       if (Array.isArray(d.y) && d.y.length === 1) {
         d.y = d.y[0];
       }
     
       // Type check & fix: if not a number or NaN → use default circular layout
       if (typeof d.x !== 'number' || isNaN(d.x)) {
         d.x = width / 2 + 100 * Math.cos(2 * Math.PI * i / nodes.length);
       }
       if (typeof d.y !== 'number' || isNaN(d.y)) {
         d.y = height / 2 + 100 * Math.sin(2 * Math.PI * i / nodes.length);
        }
       });
     
     
     
       // Dragging
     function drag(sim) {
       function dragstarted(event, d) {
         // The layout has converged; do not restart the force simulation—keep the current node positions fixed
         d.fx = d.x;
         d.fy = d.y;
       }
     
       function dragged(event, d) {
         d.fx = event.x;
         d.fy = event.y;
         d.x  = event.x;
         d.y  = event.y;
        // Update edge geometry immediately during dragging
         ticked && ticked();
       }
     
        function dragended(event, d) {
          d.fx = d.x;
          d.fy = d.y;
        
          const idStr = String(Array.isArray(d.id) ? d.id[0] : d.id);
        
          // update lastLayout
          const idx = lastLayout.findIndex(p => p.id === idStr);
          if (idx >= 0) {
            lastLayout[idx].x = d.x;
            lastLayout[idx].y = d.y;
          } else {
            lastLayout.push({ id: idStr, x: d.x, y: d.y });
          }
        
          // Sync back to currentData.nodes (for convenient JSON export)
          if (currentData) {
            const n0 = currentData.nodes.find(n => {
              const nid = String(Array.isArray(n.id) ? n.id[0] : n.id);
              return nid === idStr;
            });
            if (n0) {
              n0.x = d.x;
              n0.y = d.y;
            }
          }
        
         // Propagate the updated positions back to currentData.nodes to facilitate JSON export
          if (currentCommId) {
            layoutByCommunity.set(currentCommId, lastLayout.slice());
          }
        }
     
     
       return d3.drag()
         .on("start", dragstarted)
         .on("drag", dragged)
         .on("end", dragended);
     }
   
       const edgeSel = container.selectAll('line.edge')
       .data(straight)
       .enter().append('line')
       .attr('class', 'edge')
       .attr('stroke-width', CONST_SW)
       .attr('stroke', d => edgeColor(d))
       .attr('opacity', d => (d._highlight && d._inRange) ? 1 : 0.2);
     
   
       const simulation = d3.forceSimulation(nodes)
         .force('link',   d3.forceLink(edges).id(d => getId(d.id)).distance(100))
         .force('charge', d3.forceManyBody().strength(-120))
         .force('center', d3.forceCenter(width/2, height/2))
         .alphaDecay(0.05)
         .velocityDecay(0.9)
         .alphaMin(0.001)
         .on('tick', ticked);
     
       if (!nodes.length) { 
         d3.select('#networkViz').selectAll('*').remove();
         return;
       }
       // Node groups + multi-ring charts + dragging
       const barW = 4, gap = 2;
       const sampleCount = nodes[0].exp_vals.length, angleStep = 2 * Math.PI / sampleCount;
       const nodeSel = container.selectAll('g.node')
         .data(nodes)
         .enter().append('g')
         .attr('class', 'node')
         .call(drag(simulation)); // Drag interaction
         for (let i = 0; i < 4; ++i) simulation.tick();
         simulation.stop();
         ticked();
         fitToView();
         
         // Persist the current layout state
         lastLayout = nodes.map(n => ({
           id: String(Array.isArray(n.id) ? n.id[0] : n.id),
           x: n.x,
           y: n.y
         }));
         if (currentData) {
           const map = new Map(lastLayout.map(p => [p.id, p]));
           currentData.nodes.forEach(n => {
             const nid = String(Array.isArray(n.id) ? n.id[0] : n.id);
             const p = map.get(nid);
             if (p) {
               n.x = p.x;
               n.y = p.y;
             }
           });
         }
         
         // Update the cache for the current community
         if (currentCommId) {
           layoutByCommunity.set(currentCommId, lastLayout.slice());
         }
           nodeSel.each(function(nodeDatum) {
             const omicsTypeSelected = d3.select('#omicsType').property('value');
             const rmin = +d3.select('#rangeMin').property('value');
             const rmax = +d3.select('#rangeMax').property('value');
     
             const barW = 4, gap = 2;
             const sampleCount = nodeDatum.exp_vals.length;
             const angleStep = 2 * Math.PI / sampleCount;
     
             const ringDefs = [
               { type: 'snv',  inner: barW + gap },
               { type: 'cnv',  inner: 2 * (barW + gap) },
               { type: 'mty',  inner: 3 * (barW + gap) },
               { type: 'exp',  inner: 4 * (barW + gap) },
               { type: 'stage',inner: 5 * (barW + gap) }
             ];
     
            // Each ring determines its own metric mode: raw / norm / zscore
             const rings = ringDefs.map(r => {
               if (r.type === 'stage') {
                 return {
                   ...r,
                   vals: nodeDatum.stage_idx,
                   scale: null
                 };
               }
     
               const metric = omicsMetric[r.type] || 'raw';
               const suffix = metric === 'zscore' ? '_z'
                             : metric === 'norm'  ? '_norm'
                             : '_vals';
     
               return {
                 ...r,
                 metric,
                 vals: nodeDatum[r.type + suffix],
                 scale: colorConfig[r.type]
               };
             }).filter(r => Array.isArray(r.vals));
     
             const g = d3.select(this);
             g.selectAll('*').remove();
             rings.forEach(ring => {
               const isSelectedOmics = ring.type === omicsTypeSelected;
               const isStage = ring.type === 'stage';
     
               const slices = ring.vals.map((v, i) => ({
                 start: i * angleStep,
                 end:   (i + 1) * angleStep,
                 value: v
               }));
     
               g.selectAll(`path.r${ring.inner}`)
                 .data(slices).enter().append('path')
                 .attr('d', s => d3.arc()({
                   innerRadius: ring.inner,
                   outerRadius: ring.inner + barW,
                   startAngle: s.start,
                   endAngle:   s.end
                 }))
                 .attr('fill', s => {
                   if (s.value == null || isNaN(s.value)) return 'transparent';
                   if (!isStage && isSelectedOmics && (s.value < rmin || s.value > rmax)) {
                       return '#CCCCCC';
                   }
     	      return isStage ? getStageColorByIndex(s.value) : ring.scale(s.value);
                 })
                 .attr('fill-opacity', s => {
                   if (isStage) return (s.value == null || isNaN(s.value)) ? 0 : 1;
                   if (!isSelectedOmics) return 1;
                   return (s.value >= rmin && s.value <= rmax) ? 1 : 0.2;
                 })
                 .attr('stroke-width', isStage ? 0 : (isSelectedOmics ? 0.5 : 0))
                 .attr('stroke', s => {
                   if (isStage) return 'none';
                   if (!isSelectedOmics) return 'none';
                   return (s.value >= rmin && s.value <= rmax)
                     ? ring.scale(s.value)
                     : '#CCCCCC';
                 });
             });
     
             g.append('text')
               .text(nodeDatum.id)
               .attr('y', -((barW + gap) * rings.length) - 4)
               .attr('text-anchor', 'middle')
               .style('font-size', '10px')
               .style('pointer-events', 'none');
           });
     
     
       // Tick callback: refresh coordinates by force simulation
       function ticked() {
         // Refresh straight edges
     	  edgeSel
     	  .attr('x1', d => {
     	    const x = nodeById.get(getId(d.source))?.x ?? 0;
     	    return x;
     	  })
     	  .attr('y1', d => nodeById.get(getId(d.source))?.y ?? 0)
     	  .attr('x2', d => nodeById.get(getId(d.target))?.x ?? 0)
     	  .attr('y2', d => nodeById.get(getId(d.target))?.y ?? 0);
     	
     
         // refesh group
         nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);
       }
     
     }




  
 
    d3.select('#filterBtn').on('click', () => {
      if (typeof currentData !== 'undefined' && currentData) {
        drawNetwork(currentData);
      } else {
        console.warn('The data is not loaded completely，filter function can not continue');
      }
    });  


// Compute bounding box of container <g> and add padding
    function getContentBBox(padding = 20) {
      const svgNode = document.getElementById('networkViz');
      const g = svgNode.querySelector('g'); // <g> created in drawNetwork
      if (!g) return null;
    
      // Temporarily store the current zoom transform
      const oldTransform = g.getAttribute('transform');
      // Remove the transform to compute the overall bounding box
      if (oldTransform) g.removeAttribute('transform');
    
      const b = g.getBBox();
    
      // Restore the transform afterward to avoid affecting the visual state
      if (oldTransform) g.setAttribute('transform', oldTransform);
    
      return {
        x: b.x - padding,
        y: b.y - padding,
        width:  b.width  + 2 * padding,
        height: b.height + 2 * padding,
        svg: svgNode,
        container: g
      };
    }



// One-click fit: bring all nodes into view (auto-scale to current viewport)
    function fitToView() {
      const info = getContentBBox(40);
      if (!info) return;
      const svgSel = d3.select(info.svg);
      const width  = +svgSel.attr('width')  || 1000;
      const height = +svgSel.attr('height') || 700;
    
      const scale = Math.min(width / info.width, height / info.height) * 0.95;
      const tx = width  / 2 - scale * (info.x + info.width  / 2);
      const ty = height / 2 - scale * (info.y + info.height / 2);
    
      const t = d3.zoomIdentity.translate(tx, ty).scale(scale);
    
      if (zoom) {
        svgSel.transition().duration(300)
          .call(zoom.transform, t)
          .selection()
          .on('wheel.zoom', null)
          .on('dblclick.zoom', null);
      } else if (container) {
        d3.select(info.container)
          .attr('transform', `translate(${tx},${ty}) scale(${scale})`);
      }
    }



    function snapshotSVG() {
      const svgOriginal = document.getElementById('networkViz');
      if (!svgOriginal) return null;
    
     // Use the helper function above to obtain the overall content bounding box
     // after removing the transform
      const info = getContentBBox(20);
      if (!info) return null;
    
      // Clone the current SVG and operate only on the clone,
      // ensuring the live view remains unaffected
      const svgNode = svgOriginal.cloneNode(true);
      svgNode.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      svgNode.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    
      // Remove inline styles (e.g., width: 700%; height: 700%)
      // to prevent excessively large or distorted exported files
      svgNode.removeAttribute('style');
    
      // Key step: remove the <g> transform in the cloned SVG during export
      // so the output is no longer affected by zoom
      const gClone = svgNode.querySelector('g');
      if (gClone) {
        gClone.removeAttribute('transform');
      }
    
      // Use the bounding box to set the viewBox and the exported width/height,
      // ensuring the entire network is captured
      svgNode.setAttribute('viewBox', `${info.x} ${info.y} ${info.width} ${info.height}`);
      svgNode.setAttribute('width',  Math.round(info.width));
      svgNode.setAttribute('height', Math.round(info.height));
    
      return svgNode;
    }


    // download SVG
    function saveSVG() {
      const svgNode = snapshotSVG();
      if (!svgNode) return;
      const ser = new XMLSerializer();
      const svgStr = ser.serializeToString(svgNode);
      const blob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const id = d3.select('#commSelect').property('value') || 'community';
      const a = document.createElement('a');
      a.href = url;
      a.download = `${id}.svg`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function savePDF() {
      const svgNode = snapshotSVG();
      if (!svgNode) return;
    
      const w = svgNode.viewBox?.baseVal?.width  || svgNode.width.baseVal.value;
      const h = svgNode.viewBox?.baseVal?.height || svgNode.height.baseVal.value;
    
      const PDFCtor = (window.jsPDF || (window.jspdf && window.jspdf.jsPDF));
      if (!PDFCtor) {
        alert('jsPDF not loaded normally');
        return;
      }
    
      // Prefer using the svg2pdfFn prepared in the document head
      const svg2pdfFn =
        (typeof window.svg2pdfFn === 'function') ? window.svg2pdfFn :
        (typeof window.svg2pdf    === 'function') ? window.svg2pdf    :
        null;
    
      if (!svg2pdfFn) {
        alert('svg2pdf.js not loaded normally');
        return;
      }
    
      const pdf = new PDFCtor({
        orientation: w > h ? 'l' : 'p',
        unit: 'pt',
        format: [w, h]
      });
    
      // Generate a vector-based PDF directly via svg2pdf
      await svg2pdfFn(svgNode, pdf, {
        xOffset: 0,
        yOffset: 0,
        scale:   1,
        useCSS:  true
      });
    
      const id = d3.select('#commSelect').property('value') || 'community';
      pdf.save(`${id}.pdf`);
    }


    //build session
    function buildSessionJSON() {
      const sid = new URLSearchParams(location.search).get('sid') || '';
    
      const state = {
        sid,
        community: d3.select('#commSelect').property('value'),
        degreeRange: {
          min: +d3.select('#degMin').property('value'),
          max: +d3.select('#degMax').property('value')
        },
        dataFilter: {
          dataType:  d3.select('#dataType').property('value'),
          omicsType: d3.select('#omicsType').property('value'),
          valueRange: {
            min: +d3.select('#rangeMin').property('value'),
            max: +d3.select('#rangeMax').property('value')
          }
        },
        edgeFilter: {
          metric: d3.select('#edgeMetric').property('value'),
          range: {
            min: +d3.select('#eRangeMin').property('value'),
            max: +d3.select('#eRangeMax').property('value')
          }
        },
        colors: {
          exp: { neg: d3.select('#expNeg').property('value'), zero: d3.select('#expZero').property('value'), pos: d3.select('#expPos').property('value') },
          mty: { neg: d3.select('#mtyNeg').property('value'), zero: d3.select('#mtyZero').property('value'), pos: d3.select('#mtyPos').property('value') },
          snv: { neg: d3.select('#snvNeg').property('value'), zero: d3.select('#snvZero').property('value'), pos: d3.select('#snvPos').property('value') },
          cnv: { neg: d3.select('#cnvNeg').property('value'), zero: d3.select('#cnvZero').property('value'), pos: d3.select('#cnvPos').property('value') },
          edge:{ neg: d3.select('#edgeNeg').property('value'), zero: d3.select('#edgeZero').property('value'), pos: d3.select('#edgePos').property('value') }
        },
        // display the subset of data
        data: (typeof currentData !== 'undefined' && currentData) ? {
          nodes: currentData.nodes,
          edges: currentData.edges
        } : null,
    
        //the latest point coordinate from last time
        layout: lastLayout,
    
        // json path with ssession id
        source: sid ? `uploads/${sid}/community_map_top100.json` : 'uploads/community_map_top100.json',
    
        savedAt: new Date().toISOString()
      };
      return state;
    }

    /* trigger the downloading*/
    function saveJSON() {
      const state = buildSessionJSON();
      const text  = JSON.stringify(state, null, 2);
      const blob  = new Blob([text], { type: 'application/json;charset=utf-8' });
      const url   = URL.createObjectURL(blob);
    
      const sid  = state.sid || 'nosid';
      const comm = state.community || 'community';
    
      const a = document.createElement('a');
      a.href = url;
      a.download = `session_${sid}_${comm}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }
    
    /* =====bind the button ===== */
    const saveJSONBtn = document.getElementById('saveJSONBtn');
    if (saveJSONBtn) saveJSONBtn.onclick = () => saveJSON();

     })();
  </script>
</body>
</html>
